# 프로젝트 아키텍처 개요

이 프로젝트는 Python으로 작성된 텍스트 기반 어드벤처 게임입니다. PyScript를 사용하여 웹 브라우저에서 실행됩니다. 아키텍처의 핵심은 **의존성 주입(DI)**과 **관심사 분리(SoC)** 원칙에 따라 설계되어, 각 컴포넌트가 독립적이고 재사용 가능하며 테스트하기 쉽도록 만드는 데 중점을 둡니다.

## 주요 컴포넌트 및 역할

### 1. `main.py` - 애플리케이션 진입점 (Composition Root)

-   **역할**: 게임 애플리케이션의 가장 바깥쪽 레이어로, 모든 주요 컴포넌트를 생성하고 서로 연결(의존성 주입)하는 책임을 집니다.
-   **주요 작업**:
    -   `UIManager`, `Inventory`, `TestRunner` 등 핵심 서비스 객체를 생성합니다.
    -   생성된 객체들을 `Game` 클래스의 생성자에 주입하여 게임을 시작합니다.

### 2. `game.py` - 게임 엔진 코어

-   **역할**: 게임의 전체적인 흐름과 핵심 로직을 관장하는 중앙 클래스(`Game`)입니다.
-   **주요 작업**:
    -   `SceneFactory`와 `SceneManager`를 생성하고 설정합니다.
    -   게임 인트로 출력, 사용자 입력 루프 처리 등 전반적인 게임 생명주기를 관리합니다.
    -   체력(`health`)과 같은 전역 게임 상태를 관리합니다.
    -   사용자 입력을 받아 `SceneManager`나 `Inventory` 등 적절한 컴포넌트로 위임합니다.

### 3. `scene_manager.py` - 장면 관리 시스템

이 파일은 두 개의 주요 클래스로 구성됩니다.

-   **`SceneFactory`**:
    -   **역할**: 모든 `Scene` 인스턴스의 생성자 역할을 합니다.
    -   **주요 작업**:
        -   `game.py`에서 `register_scene()`을 통해 각 장면의 클래스와 데이터를 등록받습니다.
        -   `SceneManager`의 요청에 따라 특정 장면의 인스턴스를 생성하여 반환합니다.
-   **`SceneManager`**:
    -   **역할**: 장면의 전환과 현재 장면의 상태를 관리합니다.
    -   **주요 작업**:
        -   `switch_scene()`: `SceneFactory`를 통해 새 장면을 가져오거나 캐시된 장면을 사용하여 현재 장면을 교체합니다.
        -   `process_command()`: `game.py`로부터 받은 명령어를 현재 활성화된 `Scene` 객체로 전달합니다.

### 4. `scene.py` - 장면의 추상화

-   **역할**: 모든 개별 장면 클래스가 상속받아야 하는 추상 기반 클래스(`Scene`)를 정의합니다.
-   **주요 작업**:
    -   모든 장면이 구현해야 할 공통 인터페이스(`on_enter`, `process_keyword`, `process_combination` 등)를 정의합니다.
    -   `_discover_keyword`와 같은 헬퍼 메소드를 제공하여 자식 클래스에서 공통 로직을 재사용할 수 있도록 합니다.

### 5. `story/chapter0/*.py` - 개별 장면 구현

-   **역할**: 게임의 각 장면을 구체적으로 구현하는 파일들입니다.
-   **구조**:
    -   각 파일(`scene0.py`, `scene1.py` 등)은 `Scene`을 상속받는 고유한 클래스(`Scene0`, `Scene1` 등)를 정의합니다.
    -   각 클래스는 해당 장면에 필요한 모든 데이터(장소 이름, 초기 텍스트, 키워드 등)를 `DATA`라는 클래스 변수로 포함합니다.
    -   `process_keyword`와 `process_combination` 메소드를 오버라이드하여 해당 장면의 고유한 상호작용 로직을 캡슐화합니다.

### 6. `ui.py` - 사용자 인터페이스

-   **역할**: 화면에 텍스트를 출력하는 모든 작업을 전담하는 `UIManager` 클래스를 포함합니다.
-   **주요 작업**:
    -   서사, 시스템 메시지, 사용자 로그 등 다양한 유형의 텍스트를 HTML 요소에 렌더링합니다.
    -   체력, 시야, 인벤토리 같은 상태 표시줄을 업데이트합니다.

### 7. `entity.py` - 게임 엔티티

-   **역할**: 게임 세계에 존재하는 객체들을 정의합니다.
-   **주요 클래스**:
    -   `Item`: 플레이어가 수집할 수 있는 아이템을 정의합니다.
    -   `Inventory`: 플레이어의 소지품을 관리하며, 아이템 추가/제거/확인 등의 기능을 제공합니다.

## 아키텍처 흐름 (사용자 입력 예시)

1.  사용자가 웹 인터페이스에 "벽"을 입력하고 전송합니다.
2.  `game.py`의 `_handle_click` 이벤트 핸들러가 입력을 받아 `process_command`를 호출합니다.
3.  `Game.process_command`는 입력을 `SceneManager.process_command`로 전달합니다.
4.  `SceneManager`는 현재 활성화된 `Scene` 객체(예: `Scene1` 인스턴스)의 `process_keyword` 메소드를 호출하며 "벽"을 인자로 넘깁니다.
5.  `scene1.py`의 `Scene1.process_keyword` 메소드가 실행됩니다.
    -   "벽" 키워드에 대한 로직을 수행합니다.
    -   만약 새로운 키워드 "메모"가 발견되면, `_discover_keyword` 헬퍼 메소드를 호출합니다.
    -   `_discover_keyword`는 `ui.py`의 `UIManager`를 통해 "메모를 발견했다"는 메시지와 "시야가 넓어졌다"는 메시지를 화면에 출력합니다.
6.  로직 실행이 완료되고 각 함수가 순서대로 반환되며 다음 입력을 기다립니다.

이러한 구조 덕분에 각 컴포넌트는 자신의 책임에만 집중할 수 있으며, 예를 들어 새로운 장면을 추가할 때 `game.py`에서 단 한 줄의 등록 코드만 추가하면 되므로 확장성이 매우 뛰어납니다.
